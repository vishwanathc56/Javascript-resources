1) console.log(NaN === NaN);
console.log(NaN == NaN) ;

ans  :  false, false 

NaN is not equal to itself in Js, because NaN is used to indicate an error in a mathematical operation and should not be considered equivalent to any value. 
So the correct answer will be false,false

// --------------------------------------------------------------------------------------------------------------------------------------------------------------

let x = [1, 2, 3];
let y = [...x];
let z = x;
x.push(4);
console.log(y);
console.log(z);

ans : [1,2,3] [1,2,3,4]

Here's an explanation of what's happening:
let x = [1, 2, 3] creates an array x containing the elements 1, 2, and 3.
let y = [...x] creates a new array y containing the same elements as x by spreading the elements of x.
let z = x creates a reference to the same array x in a new variable z.
x.push(4) modifies the original array by adding element 4 to the end of the array.
Since y is a new array created by spreading the elements of x, it does not reference the same array in memory, so the original array x is not modified.
On the other hand, z is a reference to the same array in memory, so when the original array x is modified, the change is reflected in the z variable as well.

// --------------------------------------------------------------------------------------------------------------------------------------------------------------
3)const res = [1,2,3,4,5].filter(js => false);
console.log(res);

ans : []
// --------------------------------------------------------------------------------------------------------------------------------------------------------------

4) console.log(typeof NaN);

  ans : Number
// --------------------------------------------------------------------------------------------------------------------------------------------------------------
5)  const a = {};
    const b = { key: 'b' };
    const c = { key: 'c' };
    
    a[b] = 123; 
    a[c] = 456;
    
    console.log(a[b]);
    
    A : 123
    B: 456
    C:undefined
    D :ReferenceError
-------------
Answer: B
--------------

Explanation :

- Object keys are automatically converted into strings. We are trying to set an object as a key to object a, with the value of 123.

- However, when we stringify an object, it becomes "[object Object]". So what we are saying here, is that a["[object Object]"] = 123.

- Then, we can try to do the same again. c is another object that we are implicitly stringifying.

- So then, a["[object Object]"] = 456.

- Then, we log a[b], which is actually a["[object Object]"]. We just set that to 456, so it returns 456.

// --------------------------------------------------------------------------------------------------------------------------------------------------------------

